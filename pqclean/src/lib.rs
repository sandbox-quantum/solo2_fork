#![no_std]


/* automatically generated by rust-bindgen 0.65.1 */
use cty::c_int;

// pub const DILITHIUM_MODE: u32 = 5;
// pub const DILITHIUM_PUBLICKEYBYTES: u32 = 2592;
// pub const DILITHIUM_SECRETKEYBYTES: u32 = 4864;
// pub const DILITHIUM_CRYPTO_BYTES: u32 = 4595;

pub const PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_PUBLICKEYBYTES: u32 = 1952;
pub const PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_SECRETKEYBYTES: u32 = 4000;
pub const PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_BYTES: u32 = 3293;
pub const PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_ALGNAME: &[u8; 11usize] = b"Dilithium3\0";

pub fn sb_pqclean_dilithium3_clean_crypto_sign_keypair() -> ([u8;PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_PUBLICKEYBYTES as usize], [u8;PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_SECRETKEYBYTES as usize]) {
    let mut pk = [0; PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_PUBLICKEYBYTES as usize];
    let mut sk = [0; PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_SECRETKEYBYTES as usize];
    unsafe {
        PQCLEAN_DILITHIUM3_CLEAN_crypto_sign_keypair(&mut pk as *mut _, &mut sk as *mut _);
    }
    (pk,sk)
}


pub fn sb_pqclean_dilithium3_clean_crypto_sign_signature(m: &[u8], sk: &[u8;PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_SECRETKEYBYTES as usize]) -> [u8;PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_BYTES as usize] {
    let mut sig = [0; PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_BYTES as usize];
    let mut siglen = PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_BYTES as usize;
    unsafe {
        PQCLEAN_DILITHIUM3_CLEAN_crypto_sign_signature(&mut sig as *mut _, &mut siglen as *mut _, m.as_ptr(), m.len() as usize, sk.as_ptr());
    }
    sig
}

pub fn sb_pqclean_dilithium3_clean_crypto_sign_verify(sig: &[u8;PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_BYTES as usize], m: &[u8], pk: &[u8;PQCLEAN_DILITHIUM3_CLEAN_CRYPTO_PUBLICKEYBYTES as usize]) -> bool {
    let res;
    unsafe {
        res = PQCLEAN_DILITHIUM3_CLEAN_crypto_sign_verify(sig.as_ptr(), sig.len(), m.as_ptr(), m.len(), pk.as_ptr());
    }
    res == 0
}



/* automatically generated by rust-bindgen 0.65.1 */


extern "C" {
    pub fn PQCLEAN_DILITHIUM3_CLEAN_crypto_sign_keypair(
        pk: *mut u8,
        sk: *mut u8,
    ) -> c_int;
}
extern "C" {
    pub fn PQCLEAN_DILITHIUM3_CLEAN_crypto_sign_signature(
        sig: *mut u8,
        siglen: *mut usize,
        m: *const u8,
        mlen: usize,
        sk: *const u8,
    ) -> c_int;
}
extern "C" {
    pub fn PQCLEAN_DILITHIUM3_CLEAN_crypto_sign_verify(
        sig: *const u8,
        siglen: usize,
        m: *const u8,
        mlen: usize,
        pk: *const u8,
    ) -> c_int;
}
extern "C" {
    pub fn PQCLEAN_DILITHIUM3_CLEAN_crypto_sign(
        sm: *mut u8,
        smlen: *mut usize,
        m: *const u8,
        mlen: usize,
        sk: *const u8,
    ) -> c_int;
}
extern "C" {
    pub fn PQCLEAN_DILITHIUM3_CLEAN_crypto_sign_open(
        m: *mut u8,
        mlen: *mut usize,
        sm: *const u8,
        smlen: usize,
        pk: *const u8,
    ) -> c_int;
}


// extern "C" {
//     fn pqcrystals_dilithium_crypto_sign_keypair(
//         pk: *mut u8,
//         sk: *mut u8,
//     ) -> c_int;
// }
// extern "C" {
//     pub fn pqcrystals_dilithium_signature(
//         sig: *mut u8,
//         siglen: *mut usize,
//         m: *const u8,
//         mlen: usize,
//         sk: *const u8,
//     ) -> c_int;
// }
// extern "C" {
//     pub fn pqcrystals_dilithium_crypto_sign(
//         sm: *mut u8,
//         smlen: *mut usize,
//         m: *const u8,
//         mlen: usize,
//         sk: *const u8,
//     ) -> c_int;
// }
// extern "C" {
//     pub fn pqcrystals_dilithium_verify(
//         sig: *const u8,
//         siglen: usize,
//         m: *const u8,
//         mlen: usize,
//         pk: *const u8,
//     ) -> c_int;
// }
// extern "C" {
//     pub fn pqcrystals_dilithium_crypto_sign_open(
//         m: *mut u8,
//         mlen: *mut usize,
//         sm: *const u8,
//         smlen: usize,
//         pk: *const u8,
//     ) -> c_int;
// }

// use core::ffi::{c_int,c_uchar};

// extern crate alloc;

// const SEEDBYTES: usize = 32;
// const CRHBYTES: usize = 64;
// const N: usize = 256;
// const Q: usize = 8380417;
// const D: usize = 13;
// const ROOT_OF_UNITY: usize = 1753;

// const K: usize = 6;
// const L: usize = 5;
// const ETA: usize = 4;
// const TAU: usize = 49;
// const BETA: usize = 196;
// const GAMMA1: usize = 1 << 19;
// const GAMMA2: usize = (Q - 1) / 32;
// const OMEGA: usize = 55;
// const CRYPTO_ALGNAME: &str = "Dilithium3";

// const POLYT1_PACKEDBYTES: usize = 320;
// const POLYT0_PACKEDBYTES: usize = 416;
// const POLYVECH_PACKEDBYTES: usize = OMEGA + K;

// const POLYZ_PACKEDBYTES: usize = 640;

// const POLYW1_PACKEDBYTES: usize = 128;

// const POLYETA_PACKEDBYTES: usize = 128;

// const CRYPTO_PUBLICKEYBYTES: usize = SEEDBYTES + K * POLYT1_PACKEDBYTES;
// const CRYPTO_SECRETKEYBYTES: usize = 3 * SEEDBYTES
//     + L * POLYETA_PACKEDBYTES
//     + K * POLYETA_PACKEDBYTES
//     + K * POLYT0_PACKEDBYTES;
// const CRYPTO_BYTES: usize = SEEDBYTES + L * POLYZ_PACKEDBYTES + POLYVECH_PACKEDBYTES;

// const DILITHIUM_PUBLICKEYBYTES: usize = CRYPTO_PUBLICKEYBYTES;
// const DILITHIUM_SECRETKEYBYTES: usize = CRYPTO_SECRETKEYBYTES;
// const DILITHIUM_CRYPTO_BYTES: usize = CRYPTO_BYTES;

// pub const DILITHIUM_PUBLICKEYBYTES: usize = 32 + 6 * 320; // 1952
// pub const DILITHIUM_SECRETKEYBYTES: usize = 3 * 32 + 5 * 128 + 6 * 128 + 6 * 416; // 3072
// const DILITHIUM_CRYPTO_BYTES: usize = 32 + 5 * 640 + 55 + 6; // 3335

// use crate::newtype_buffer;
// use alloc::vec::Vec;
// use alloc::string::String;
// /// Implements a buffer for cryptographic objects
// #[macro_export]
// macro_rules! newtype_buffer {
//     ($name: ident, $name_ref: ident) => {
//         /// New owned buffer
//         ///
//         /// Optional support for `serde` if that feature is enabled.
//         #[derive(Debug, Clone, PartialEq, Eq)]
//         #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
//         pub struct $name {
//             bytes: Vec<u8>,
//         }

//         impl $name {
//             /// Obtain the contained vector
//             pub fn into_vec(self) -> Vec<u8> {
//                 self.bytes
//             }
//         }

//         /// Reference version of this type.
//         ///
//         /// Allows for copy-less usage
//         /// Construct it through the algorithm API functions
//         #[derive(Debug, Clone, Copy, PartialEq, Eq)]
//         pub struct $name_ref<'a> {
//             bytes: &'a [u8],
//         }

//         impl<'a> $name_ref<'a> {
//             /// Construct a new container around this reference version
//             fn new(bytes: &'a [u8]) -> $name_ref<'a> {
//                 $name_ref { bytes }
//             }

//             /// Clone this into the owned variant
//             pub fn to_owned(self) -> $name {
//                 $name {
//                     bytes: self.bytes.to_vec(),
//                 }
//             }
//         }

//         impl<'a> From<&'a $name> for $name_ref<'a> {
//             fn from(buf: &'a $name) -> $name_ref<'a> {
//                 $name_ref::new(&buf.bytes)
//             }
//         }

//         impl<'a> From<&'a $name_ref<'a>> for $name_ref<'a> {
//             fn from(buf: &'a $name_ref) -> $name_ref<'a> {
//                 *buf
//             }
//         }

//         impl<'a> core::ops::Deref for $name_ref<'a> {
//             type Target = [u8];
//             fn deref(&self) -> &Self::Target {
//                 &self.bytes
//             }
//         }

//         impl AsRef<[u8]> for $name {
//             fn as_ref(&self) -> &[u8] {
//                 self.bytes.as_ref()
//             }
//         }

//         impl $name {
//             /// Length in bytes
//             #[allow(clippy::len_without_is_empty)]
//             pub fn len(&self) -> usize {
//                 self.bytes.len()
//             }
//         }
//     };
// }

// newtype_buffer!(PublicKey, PublicKeyRef);
// newtype_buffer!(SecretKey, SecretKeyRef);

// pub const DILITHIUM_PUBLICKEYBYTES: usize = 1952;
// pub const DILITHIUM_SECRETKEYBYTES: usize = 4000;


// extern "C" {
//     pub fn PQCLEAN_DILITHIUM3_CLEAN_crypto_sign_keypair(pk: *mut u8, sk: *mut u8) -> c_int;
// }
    

// #[derive(Debug)]
// #[non_exhaustive]
// /// Possible errors
// pub enum Error {
//     /// Indicates an algorithm has been disabled
//     AlgorithmDisabled,
//     /// Generic error
//     Error,
//     /// Error occurred in OpenSSL functions external to liboqs
//     #[allow(clippy::upper_case_acronyms)]
//     ErrorExternalOpenSSL,
//     /// Invalid length of a public object
//     InvalidLength,
// }


// fn status_to_result(status: u8) -> Result<(), E> {
//     match status {
//         0 => Ok(()),
//         1 => Err(Error::Error),
//         // OQS_STATUS::OQS_EXTERNAL_LIB_ERROR_OPENSSL => Err(Error::ErrorExternalOpenSSL),
//     }
// }

// pub fn keypair() -> Result<(PublicKey, SecretKey), String> {
//     // let sig = unsafe { self.sig.as_ref() };
//     let func = pqcrystals_dilithium_crypto_sign_keypair.as_ref().unwrap();
//     let mut pk = PublicKey {
//         bytes: Vec::with_capacity(DILITHIUM_PUBLICKEYBYTES),
//     };
//     let mut sk = SecretKey {
//         bytes: Vec::with_capacity(DILITHIUM_SECRETKEYBYTES),
//     };
//     let status = unsafe { func(pk.bytes.as_mut_ptr(), sk.bytes.as_mut_ptr()) };
//     // update the lengths of the vecs
//     unsafe {
//         pk.bytes.set_len(DILITHIUM_PUBLICKEYBYTES);
//         sk.bytes.set_len(DILITHIUM_SECRETKEYBYTES);
//     }
//     // status_to_result(status)?;
//     // Ok((pk, sk))
//     if status == 0 {
//         Ok((pk, sk))
//     } else {
//         Err(String::from("Key pair generation failed"))
//     }

// }



// impl Sig {
//     pub fn keypair(&self) -> Result<(PublicKey, SecretKey)> {
//         // let sig = unsafe { self.sig.as_ref() };
//         let func = pqcrystals_dilithium_crypto_sign_keypair.as_ref().unwrap();
//         let mut pk = PublicKey {
//             bytes: Vec::with_capacity(sig.length_public_key),
//         };
//         let mut sk = SecretKey {
//             bytes: Vec::with_capacity(sig.length_secret_key),
//         };
//         let status = unsafe { func(pk.bytes.as_mut_ptr(), sk.bytes.as_mut_ptr()) };
//         // update the lengths of the vecs
//         unsafe {
//             pk.bytes.set_len(sig.length_public_key);
//             sk.bytes.set_len(sig.length_secret_key);
//         }
//         status_to_result(status)?;
//         Ok((pk, sk))
//     }
// }

// extern "C" {
//     pub fn crypto_sign_keypair(pk: *mut u8, sk: *mut u8) -> c_int;
// }
// extern "C" {
//     pub fn crypto_sign_signature(
//         sig: *mut u8,
//         siglen: *mut usize,
//         m: *const u8,
//         mlen: usize,
//         sk: *const u8,
//     ) -> c_int;
// }
// extern "C" {
//     pub fn crypto_sign(
//         sm: *mut u8,
//         smlen: *mut usize,
//         m: *const u8,
//         mlen: usize,
//         sk: *const u8,
//     ) -> c_int;
// }
// extern "C" {
//     pub fn crypto_sign_verify(
//         sig: *const u8,
//         siglen: usize,
//         m: *const u8,
//         mlen: usize,
//         pk: *const u8,
//     ) -> c_int;
// }
// extern "C" {
//     pub fn crypto_sign_open(
//         m: *mut u8,
//         mlen: *mut usize,
//         sm: *const u8,
//         smlen: usize,
//         pk: *const u8,
//     ) -> c_int;
// }







// use libc::core::ffi::c_int;
// use libc::core::ffi::size_t;

// pub const PQCLEAN_DILITHIUM2_CLEAN_CRYPTO_PUBLICKEYBYTES: u32 = 1312;
// pub const PQCLEAN_DILITHIUM2_CLEAN_CRYPTO_SECRETKEYBYTES: u32 = 2528;
// pub const PQCLEAN_DILITHIUM2_CLEAN_CRYPTO_BYTES: u32 = 2420;
// pub const PQCLEAN_DILITHIUM2_CLEAN_CRYPTO_ALGNAME: &[u8; 11usize] = b"Dilithium2\0";



// // #[link(name = "your_c_library")]
// extern "C" {
//     pub fn crypto_sign_keypair(pk: *mut u8, sk: *mut u8) -> c_int;
//     pub fn crypto_sign_signature(
//         sig: *mut u8,
//         siglen: *mut usize,
//         m: *const u8,
//         mlen: usize,
//         sk: *const u8,
//     ) -> c_int;
//     pub fn crypto_sign(
//         sm: *mut u8,
//         smlen: *mut usize,
//         m: *const u8,
//         mlen: usize,
//         sk: *const u8,
//     ) -> c_int;
//     pub fn crypto_sign_verify(
//         sig: *const u8,
//         siglen: usize,
//         m: *const u8,
//         mlen: usize,
//         pk: *const u8,
//     ) -> c_int;
//     pub fn crypto_sign_open(
//         m: *mut u8,
//         mlen: *mut usize,
//         sm: *const u8,
//         smlen: usize,
//         pk: *const u8,
//     ) -> c_int;
// }

// pub fn sign_keypair(pk: &mut [u8], sk: &mut [u8]) -> bool {
//     unsafe { crypto_sign_keypair(pk.as_mut_ptr(), sk.as_mut_ptr()) == 0 }
// }

// pub fn sign_signature(sig: &mut [u8], m: &[u8], sk: &[u8]) -> Option<usize> {
//     let mut siglen: usize = 0;
//     let res = unsafe {
//         crypto_sign_signature(
//             sig.as_mut_ptr(),
//             &mut siglen as *mut usize,
//             m.as_ptr(),
//             m.len(),
//             sk.as_ptr(),
//         )
//     };
//     if res == 0 {
//         Some(siglen)
//     } else {
//         None
//     }
// }

// pub fn sign(sm: &mut [u8], m: &[u8], sk: &[u8]) -> Option<usize> {
//     let mut smlen: usize = 0;
//     let res = unsafe {
//         crypto_sign(
//             sm.as_mut_ptr(),
//             &mut smlen as *mut usize,
//             m.as_ptr(),
//             m.len(),
//             sk.as_ptr(),
//         )
//     };
//     if res == 0 {
//         Some(smlen)
//     } else {
//         None
//     }
// }

// pub fn sign_verify(sig: &[u8], m: &[u8], pk: &[u8]) -> bool {
//     unsafe {
//         crypto_sign_verify(
//             sig.as_ptr(),
//             sig.len(),
//             m.as_ptr(),
//             m.len(),
//             pk.as_ptr(),
//         ) == 0
//     }
// }

// pub fn sign_open(m: &mut [u8], sm: &[u8], pk: &[u8]) -> Option<usize> {
//     let mut mlen: usize = 0;
//     let res = unsafe {
//         crypto_sign_open(
//             m.as_mut_ptr(),
//             &mut mlen as *mut usize,
//             sm.as_ptr(),
//             sm.len(),
//             pk.as_ptr(),
//         )
//     };
//     if res == 0 {
//         Some(mlen)
//     } else {
//         None
//     }
// }

